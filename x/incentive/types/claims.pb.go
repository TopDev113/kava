// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kava/incentive/v1beta1/claims.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ClaimType is the type of claim
type ClaimType int32

const (
	// indicates an invalid claim type
	CLAIM_TYPE_UNSPECIFIED ClaimType = 0
	// claim type for hard borrow rewards
	CLAIM_TYPE_HARD_BORROW ClaimType = 1
	// claim type for hard supply rewards
	CLAIM_TYPE_HARD_SUPPLY ClaimType = 2
	// claim type for delegator rewards
	CLAIM_TYPE_DELEGATOR ClaimType = 3
	// claim type for earn rewards
	CLAIM_TYPE_EARN ClaimType = 4
	// claim type for savings rewards
	CLAIM_TYPE_SAVINGS ClaimType = 5
	// claim type for swap rewards
	CLAIM_TYPE_SWAP ClaimType = 6
	// claim type for usdx minting rewards
	CLAIM_TYPE_USDX_MINTING ClaimType = 7
)

var ClaimType_name = map[int32]string{
	0: "CLAIM_TYPE_UNSPECIFIED",
	1: "CLAIM_TYPE_HARD_BORROW",
	2: "CLAIM_TYPE_HARD_SUPPLY",
	3: "CLAIM_TYPE_DELEGATOR",
	4: "CLAIM_TYPE_EARN",
	5: "CLAIM_TYPE_SAVINGS",
	6: "CLAIM_TYPE_SWAP",
	7: "CLAIM_TYPE_USDX_MINTING",
}

var ClaimType_value = map[string]int32{
	"CLAIM_TYPE_UNSPECIFIED":  0,
	"CLAIM_TYPE_HARD_BORROW":  1,
	"CLAIM_TYPE_HARD_SUPPLY":  2,
	"CLAIM_TYPE_DELEGATOR":    3,
	"CLAIM_TYPE_EARN":         4,
	"CLAIM_TYPE_SAVINGS":      5,
	"CLAIM_TYPE_SWAP":         6,
	"CLAIM_TYPE_USDX_MINTING": 7,
}

func (x ClaimType) String() string {
	return proto.EnumName(ClaimType_name, int32(x))
}

func (ClaimType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{0}
}

// BaseClaim is a claim with a single reward coin types
type BaseClaim struct {
	Owner  github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	Reward types.Coin                                    `protobuf:"bytes,2,opt,name=reward,proto3" json:"reward"`
}

func (m *BaseClaim) Reset()         { *m = BaseClaim{} }
func (m *BaseClaim) String() string { return proto.CompactTextString(m) }
func (*BaseClaim) ProtoMessage()    {}
func (*BaseClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{0}
}
func (m *BaseClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseClaim.Merge(m, src)
}
func (m *BaseClaim) XXX_Size() int {
	return m.Size()
}
func (m *BaseClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseClaim.DiscardUnknown(m)
}

var xxx_messageInfo_BaseClaim proto.InternalMessageInfo

// BaseMultiClaim is a claim with multiple reward coin types
type BaseMultiClaim struct {
	Owner  github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	Reward github_com_cosmos_cosmos_sdk_types.Coins      `protobuf:"bytes,2,rep,name=reward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"reward"`
}

func (m *BaseMultiClaim) Reset()         { *m = BaseMultiClaim{} }
func (m *BaseMultiClaim) String() string { return proto.CompactTextString(m) }
func (*BaseMultiClaim) ProtoMessage()    {}
func (*BaseMultiClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{1}
}
func (m *BaseMultiClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseMultiClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseMultiClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseMultiClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseMultiClaim.Merge(m, src)
}
func (m *BaseMultiClaim) XXX_Size() int {
	return m.Size()
}
func (m *BaseMultiClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseMultiClaim.DiscardUnknown(m)
}

var xxx_messageInfo_BaseMultiClaim proto.InternalMessageInfo

// RewardIndex stores reward accumulation information
type RewardIndex struct {
	CollateralType string                                 `protobuf:"bytes,1,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty"`
	RewardFactor   github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=reward_factor,json=rewardFactor,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"reward_factor"`
}

func (m *RewardIndex) Reset()         { *m = RewardIndex{} }
func (m *RewardIndex) String() string { return proto.CompactTextString(m) }
func (*RewardIndex) ProtoMessage()    {}
func (*RewardIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{2}
}
func (m *RewardIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardIndex.Merge(m, src)
}
func (m *RewardIndex) XXX_Size() int {
	return m.Size()
}
func (m *RewardIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardIndex.DiscardUnknown(m)
}

var xxx_messageInfo_RewardIndex proto.InternalMessageInfo

// RewardIndexesProto defines a Protobuf wrapper around a RewardIndexes slice
type RewardIndexesProto struct {
	RewardIndexes RewardIndexes `protobuf:"bytes,1,rep,name=reward_indexes,json=rewardIndexes,proto3,castrepeated=RewardIndexes" json:"reward_indexes"`
}

func (m *RewardIndexesProto) Reset()         { *m = RewardIndexesProto{} }
func (m *RewardIndexesProto) String() string { return proto.CompactTextString(m) }
func (*RewardIndexesProto) ProtoMessage()    {}
func (*RewardIndexesProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{3}
}
func (m *RewardIndexesProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardIndexesProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardIndexesProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardIndexesProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardIndexesProto.Merge(m, src)
}
func (m *RewardIndexesProto) XXX_Size() int {
	return m.Size()
}
func (m *RewardIndexesProto) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardIndexesProto.DiscardUnknown(m)
}

var xxx_messageInfo_RewardIndexesProto proto.InternalMessageInfo

// TypedRewardIndexes defines a RewardIndexes slice with its corresponding
// claim and collateral type
type TypedRewardIndexes struct {
	ClaimType      ClaimType     `protobuf:"varint,1,opt,name=claim_type,json=claimType,proto3,enum=kava.incentive.v1beta1.ClaimType" json:"claim_type,omitempty"`
	CollateralType string        `protobuf:"bytes,2,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty"`
	RewardIndexes  RewardIndexes `protobuf:"bytes,3,rep,name=reward_indexes,json=rewardIndexes,proto3,castrepeated=RewardIndexes" json:"reward_indexes"`
}

func (m *TypedRewardIndexes) Reset()         { *m = TypedRewardIndexes{} }
func (m *TypedRewardIndexes) String() string { return proto.CompactTextString(m) }
func (*TypedRewardIndexes) ProtoMessage()    {}
func (*TypedRewardIndexes) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{4}
}
func (m *TypedRewardIndexes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypedRewardIndexes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypedRewardIndexes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypedRewardIndexes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypedRewardIndexes.Merge(m, src)
}
func (m *TypedRewardIndexes) XXX_Size() int {
	return m.Size()
}
func (m *TypedRewardIndexes) XXX_DiscardUnknown() {
	xxx_messageInfo_TypedRewardIndexes.DiscardUnknown(m)
}

var xxx_messageInfo_TypedRewardIndexes proto.InternalMessageInfo

// MultiRewardIndex stores reward accumulation information on multiple reward types
type MultiRewardIndex struct {
	CollateralType string        `protobuf:"bytes,1,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty"`
	RewardIndexes  RewardIndexes `protobuf:"bytes,2,rep,name=reward_indexes,json=rewardIndexes,proto3,castrepeated=RewardIndexes" json:"reward_indexes"`
}

func (m *MultiRewardIndex) Reset()         { *m = MultiRewardIndex{} }
func (m *MultiRewardIndex) String() string { return proto.CompactTextString(m) }
func (*MultiRewardIndex) ProtoMessage()    {}
func (*MultiRewardIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{5}
}
func (m *MultiRewardIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiRewardIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiRewardIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiRewardIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiRewardIndex.Merge(m, src)
}
func (m *MultiRewardIndex) XXX_Size() int {
	return m.Size()
}
func (m *MultiRewardIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiRewardIndex.DiscardUnknown(m)
}

var xxx_messageInfo_MultiRewardIndex proto.InternalMessageInfo

// MultiRewardIndexesProto defines a Protobuf wrapper around a MultiRewardIndexes slice
type MultiRewardIndexesProto struct {
	MultiRewardIndexes MultiRewardIndexes `protobuf:"bytes,1,rep,name=multi_reward_indexes,json=multiRewardIndexes,proto3,castrepeated=MultiRewardIndexes" json:"multi_reward_indexes"`
}

func (m *MultiRewardIndexesProto) Reset()         { *m = MultiRewardIndexesProto{} }
func (m *MultiRewardIndexesProto) String() string { return proto.CompactTextString(m) }
func (*MultiRewardIndexesProto) ProtoMessage()    {}
func (*MultiRewardIndexesProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{6}
}
func (m *MultiRewardIndexesProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiRewardIndexesProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiRewardIndexesProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiRewardIndexesProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiRewardIndexesProto.Merge(m, src)
}
func (m *MultiRewardIndexesProto) XXX_Size() int {
	return m.Size()
}
func (m *MultiRewardIndexesProto) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiRewardIndexesProto.DiscardUnknown(m)
}

var xxx_messageInfo_MultiRewardIndexesProto proto.InternalMessageInfo

// USDXMintingClaim is for USDX minting rewards
type USDXMintingClaim struct {
	BaseClaim     `protobuf:"bytes,1,opt,name=base_claim,json=baseClaim,proto3,embedded=base_claim" json:"base_claim"`
	RewardIndexes RewardIndexes `protobuf:"bytes,2,rep,name=reward_indexes,json=rewardIndexes,proto3,castrepeated=RewardIndexes" json:"reward_indexes"`
}

func (m *USDXMintingClaim) Reset()         { *m = USDXMintingClaim{} }
func (m *USDXMintingClaim) String() string { return proto.CompactTextString(m) }
func (*USDXMintingClaim) ProtoMessage()    {}
func (*USDXMintingClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{7}
}
func (m *USDXMintingClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *USDXMintingClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_USDXMintingClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *USDXMintingClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_USDXMintingClaim.Merge(m, src)
}
func (m *USDXMintingClaim) XXX_Size() int {
	return m.Size()
}
func (m *USDXMintingClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_USDXMintingClaim.DiscardUnknown(m)
}

var xxx_messageInfo_USDXMintingClaim proto.InternalMessageInfo

// HardLiquidityProviderClaim stores the hard liquidity provider rewards that can be claimed by owner
type HardLiquidityProviderClaim struct {
	BaseMultiClaim      `protobuf:"bytes,1,opt,name=base_claim,json=baseClaim,proto3,embedded=base_claim" json:"base_claim"`
	SupplyRewardIndexes MultiRewardIndexes `protobuf:"bytes,2,rep,name=supply_reward_indexes,json=supplyRewardIndexes,proto3,castrepeated=MultiRewardIndexes" json:"supply_reward_indexes"`
	BorrowRewardIndexes MultiRewardIndexes `protobuf:"bytes,3,rep,name=borrow_reward_indexes,json=borrowRewardIndexes,proto3,castrepeated=MultiRewardIndexes" json:"borrow_reward_indexes"`
}

func (m *HardLiquidityProviderClaim) Reset()         { *m = HardLiquidityProviderClaim{} }
func (m *HardLiquidityProviderClaim) String() string { return proto.CompactTextString(m) }
func (*HardLiquidityProviderClaim) ProtoMessage()    {}
func (*HardLiquidityProviderClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{8}
}
func (m *HardLiquidityProviderClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HardLiquidityProviderClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HardLiquidityProviderClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HardLiquidityProviderClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HardLiquidityProviderClaim.Merge(m, src)
}
func (m *HardLiquidityProviderClaim) XXX_Size() int {
	return m.Size()
}
func (m *HardLiquidityProviderClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_HardLiquidityProviderClaim.DiscardUnknown(m)
}

var xxx_messageInfo_HardLiquidityProviderClaim proto.InternalMessageInfo

// DelegatorClaim stores delegation rewards that can be claimed by owner
type DelegatorClaim struct {
	BaseMultiClaim `protobuf:"bytes,1,opt,name=base_claim,json=baseClaim,proto3,embedded=base_claim" json:"base_claim"`
	RewardIndexes  MultiRewardIndexes `protobuf:"bytes,2,rep,name=reward_indexes,json=rewardIndexes,proto3,castrepeated=MultiRewardIndexes" json:"reward_indexes"`
}

func (m *DelegatorClaim) Reset()         { *m = DelegatorClaim{} }
func (m *DelegatorClaim) String() string { return proto.CompactTextString(m) }
func (*DelegatorClaim) ProtoMessage()    {}
func (*DelegatorClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{9}
}
func (m *DelegatorClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegatorClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegatorClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegatorClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegatorClaim.Merge(m, src)
}
func (m *DelegatorClaim) XXX_Size() int {
	return m.Size()
}
func (m *DelegatorClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegatorClaim.DiscardUnknown(m)
}

var xxx_messageInfo_DelegatorClaim proto.InternalMessageInfo

// SwapClaim stores the swap rewards that can be claimed by owner
type SwapClaim struct {
	BaseMultiClaim `protobuf:"bytes,1,opt,name=base_claim,json=baseClaim,proto3,embedded=base_claim" json:"base_claim"`
	RewardIndexes  MultiRewardIndexes `protobuf:"bytes,2,rep,name=reward_indexes,json=rewardIndexes,proto3,castrepeated=MultiRewardIndexes" json:"reward_indexes"`
}

func (m *SwapClaim) Reset()         { *m = SwapClaim{} }
func (m *SwapClaim) String() string { return proto.CompactTextString(m) }
func (*SwapClaim) ProtoMessage()    {}
func (*SwapClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{10}
}
func (m *SwapClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapClaim.Merge(m, src)
}
func (m *SwapClaim) XXX_Size() int {
	return m.Size()
}
func (m *SwapClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapClaim.DiscardUnknown(m)
}

var xxx_messageInfo_SwapClaim proto.InternalMessageInfo

// SavingsClaim stores the savings rewards that can be claimed by owner
type SavingsClaim struct {
	BaseMultiClaim `protobuf:"bytes,1,opt,name=base_claim,json=baseClaim,proto3,embedded=base_claim" json:"base_claim"`
	RewardIndexes  MultiRewardIndexes `protobuf:"bytes,2,rep,name=reward_indexes,json=rewardIndexes,proto3,castrepeated=MultiRewardIndexes" json:"reward_indexes"`
}

func (m *SavingsClaim) Reset()         { *m = SavingsClaim{} }
func (m *SavingsClaim) String() string { return proto.CompactTextString(m) }
func (*SavingsClaim) ProtoMessage()    {}
func (*SavingsClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{11}
}
func (m *SavingsClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavingsClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavingsClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavingsClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavingsClaim.Merge(m, src)
}
func (m *SavingsClaim) XXX_Size() int {
	return m.Size()
}
func (m *SavingsClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_SavingsClaim.DiscardUnknown(m)
}

var xxx_messageInfo_SavingsClaim proto.InternalMessageInfo

// EarnClaim stores the earn rewards that can be claimed by owner
type EarnClaim struct {
	BaseMultiClaim `protobuf:"bytes,1,opt,name=base_claim,json=baseClaim,proto3,embedded=base_claim" json:"base_claim"`
	RewardIndexes  MultiRewardIndexes `protobuf:"bytes,2,rep,name=reward_indexes,json=rewardIndexes,proto3,castrepeated=MultiRewardIndexes" json:"reward_indexes"`
}

func (m *EarnClaim) Reset()         { *m = EarnClaim{} }
func (m *EarnClaim) String() string { return proto.CompactTextString(m) }
func (*EarnClaim) ProtoMessage()    {}
func (*EarnClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{12}
}
func (m *EarnClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EarnClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EarnClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EarnClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EarnClaim.Merge(m, src)
}
func (m *EarnClaim) XXX_Size() int {
	return m.Size()
}
func (m *EarnClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_EarnClaim.DiscardUnknown(m)
}

var xxx_messageInfo_EarnClaim proto.InternalMessageInfo

// Claim stores any generic rewards that can be claimed by owner
type Claim struct {
	Type          ClaimType                                     `protobuf:"varint,1,opt,name=type,proto3,enum=kava.incentive.v1beta1.ClaimType" json:"type,omitempty"`
	Owner         github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	Reward        github_com_cosmos_cosmos_sdk_types.Coins      `protobuf:"bytes,3,rep,name=reward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"reward"`
	RewardIndexes MultiRewardIndexes                            `protobuf:"bytes,4,rep,name=reward_indexes,json=rewardIndexes,proto3,castrepeated=MultiRewardIndexes" json:"reward_indexes"`
}

func (m *Claim) Reset()         { *m = Claim{} }
func (m *Claim) String() string { return proto.CompactTextString(m) }
func (*Claim) ProtoMessage()    {}
func (*Claim) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f7515029623a895, []int{13}
}
func (m *Claim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Claim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Claim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Claim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Claim.Merge(m, src)
}
func (m *Claim) XXX_Size() int {
	return m.Size()
}
func (m *Claim) XXX_DiscardUnknown() {
	xxx_messageInfo_Claim.DiscardUnknown(m)
}

var xxx_messageInfo_Claim proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("kava.incentive.v1beta1.ClaimType", ClaimType_name, ClaimType_value)
	proto.RegisterType((*BaseClaim)(nil), "kava.incentive.v1beta1.BaseClaim")
	proto.RegisterType((*BaseMultiClaim)(nil), "kava.incentive.v1beta1.BaseMultiClaim")
	proto.RegisterType((*RewardIndex)(nil), "kava.incentive.v1beta1.RewardIndex")
	proto.RegisterType((*RewardIndexesProto)(nil), "kava.incentive.v1beta1.RewardIndexesProto")
	proto.RegisterType((*TypedRewardIndexes)(nil), "kava.incentive.v1beta1.TypedRewardIndexes")
	proto.RegisterType((*MultiRewardIndex)(nil), "kava.incentive.v1beta1.MultiRewardIndex")
	proto.RegisterType((*MultiRewardIndexesProto)(nil), "kava.incentive.v1beta1.MultiRewardIndexesProto")
	proto.RegisterType((*USDXMintingClaim)(nil), "kava.incentive.v1beta1.USDXMintingClaim")
	proto.RegisterType((*HardLiquidityProviderClaim)(nil), "kava.incentive.v1beta1.HardLiquidityProviderClaim")
	proto.RegisterType((*DelegatorClaim)(nil), "kava.incentive.v1beta1.DelegatorClaim")
	proto.RegisterType((*SwapClaim)(nil), "kava.incentive.v1beta1.SwapClaim")
	proto.RegisterType((*SavingsClaim)(nil), "kava.incentive.v1beta1.SavingsClaim")
	proto.RegisterType((*EarnClaim)(nil), "kava.incentive.v1beta1.EarnClaim")
	proto.RegisterType((*Claim)(nil), "kava.incentive.v1beta1.Claim")
}

func init() {
	proto.RegisterFile("kava/incentive/v1beta1/claims.proto", fileDescriptor_5f7515029623a895)
}

var fileDescriptor_5f7515029623a895 = []byte{
	// 885 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0xcf, 0xa4, 0x69, 0x21, 0xaf, 0xdd, 0xac, 0x35, 0xfd, 0xb3, 0xdd, 0x20, 0x39, 0x4b, 0x56,
	0x5a, 0x2a, 0x50, 0x1d, 0x76, 0x11, 0xe2, 0x8a, 0xdd, 0x64, 0x5b, 0xa3, 0x36, 0x8d, 0xec, 0x96,
	0xdd, 0xe5, 0x80, 0x35, 0xb1, 0x87, 0x60, 0xd5, 0xf1, 0x04, 0xdb, 0x4d, 0x9a, 0x6f, 0x80, 0xc4,
	0x05, 0xbe, 0x00, 0x17, 0x38, 0x71, 0xe6, 0x0b, 0x70, 0x2b, 0x12, 0x42, 0x15, 0x12, 0x12, 0xe2,
	0x10, 0xd8, 0xf6, 0x0b, 0x70, 0xe6, 0x84, 0x3c, 0x76, 0x53, 0x37, 0x75, 0x56, 0xcb, 0x2a, 0xe9,
	0xa1, 0xa7, 0x8c, 0xe7, 0x3d, 0xbf, 0xdf, 0x9f, 0xf7, 0xc6, 0xb1, 0xe1, 0xfe, 0x01, 0xe9, 0x92,
	0x8a, 0xed, 0x9a, 0xd4, 0x0d, 0xec, 0x2e, 0xad, 0x74, 0x1f, 0x36, 0x69, 0x40, 0x1e, 0x56, 0x4c,
	0x87, 0xd8, 0x6d, 0x5f, 0xea, 0x78, 0x2c, 0x60, 0x78, 0x25, 0x4c, 0x92, 0x86, 0x49, 0x52, 0x9c,
	0x54, 0x5c, 0x6a, 0xb1, 0x16, 0xe3, 0x29, 0x95, 0x70, 0x15, 0x65, 0x17, 0xef, 0x9a, 0xcc, 0x6f,
	0x33, 0xdf, 0x88, 0x02, 0xd1, 0x45, 0x1c, 0x12, 0xa3, 0xab, 0x4a, 0x93, 0xf8, 0x09, 0x28, 0x66,
	0xbb, 0x51, 0xbc, 0xfc, 0x3d, 0x82, 0xbc, 0x42, 0x7c, 0xba, 0x11, 0xa2, 0xe3, 0x4f, 0x61, 0x96,
	0xf5, 0x5c, 0xea, 0xad, 0xa2, 0x7b, 0x68, 0x6d, 0x41, 0xd9, 0xfa, 0x77, 0x50, 0x5a, 0x6f, 0xd9,
	0xc1, 0xe7, 0x87, 0x4d, 0xc9, 0x64, 0xed, 0xb8, 0x72, 0xfc, 0xb3, 0xee, 0x5b, 0x07, 0x95, 0xa0,
	0xdf, 0xa1, 0xbe, 0x24, 0x9b, 0xa6, 0x6c, 0x59, 0x1e, 0xf5, 0xfd, 0xdf, 0x7e, 0x5c, 0x5f, 0x8c,
	0xf1, 0xe3, 0x1d, 0xa5, 0x1f, 0x50, 0x5f, 0x8b, 0xca, 0xe2, 0x0f, 0x60, 0xce, 0xa3, 0x3d, 0xe2,
	0x59, 0xab, 0xd9, 0x7b, 0x68, 0x6d, 0xfe, 0xd1, 0x5d, 0x29, 0x4e, 0x0e, 0xe9, 0x9d, 0x8b, 0x94,
	0x36, 0x98, 0xed, 0x2a, 0xb9, 0xe3, 0x41, 0x29, 0xa3, 0xc5, 0xe9, 0xe5, 0xdf, 0x11, 0x14, 0x42,
	0x9a, 0x3b, 0x87, 0x4e, 0x60, 0x5f, 0x0f, 0x57, 0x33, 0xc1, 0x75, 0xe6, 0xc5, 0x5c, 0xdf, 0x0d,
	0xb9, 0xfe, 0xf0, 0x57, 0x69, 0xed, 0x25, 0xf0, 0xc3, 0x1b, 0xfc, 0xa1, 0xae, 0xaf, 0x10, 0xcc,
	0x6b, 0x7c, 0xa9, 0xba, 0x16, 0x3d, 0xc2, 0x6f, 0xc1, 0x6d, 0x93, 0x39, 0x0e, 0x09, 0xa8, 0x47,
	0x1c, 0x23, 0xbc, 0x83, 0xcb, 0xcb, 0x6b, 0x85, 0x8b, 0xed, 0xbd, 0x7e, 0x87, 0x62, 0x1d, 0x6e,
	0x45, 0x25, 0x8c, 0xcf, 0x88, 0x19, 0x30, 0x8f, 0x1b, 0xba, 0xa0, 0x48, 0x21, 0x93, 0x3f, 0x07,
	0xa5, 0x07, 0x2f, 0xc1, 0xa4, 0x4a, 0x4d, 0x6d, 0x21, 0x2a, 0xf2, 0x98, 0xd7, 0x28, 0xf7, 0x00,
	0x27, 0xc8, 0x50, 0xbf, 0xc1, 0x67, 0x91, 0x40, 0x21, 0x86, 0xb2, 0xa3, 0xed, 0x55, 0xc4, 0x0d,
	0xb9, 0x2f, 0xa5, 0x0f, 0xa9, 0x94, 0xa8, 0xa1, 0x2c, 0xc7, 0xd6, 0xdc, 0xba, 0x54, 0x58, 0x8b,
	0xc9, 0xc7, 0x97, 0xe5, 0x53, 0x04, 0x38, 0x94, 0x65, 0x5d, 0xca, 0xc2, 0x1f, 0x02, 0xf0, 0x53,
	0x71, 0x61, 0x44, 0xe1, 0xd1, 0x9b, 0xe3, 0x50, 0xf9, 0x54, 0x84, 0x45, 0xb4, 0xbc, 0x79, 0xbe,
	0x4c, 0xf3, 0x33, 0x9b, 0xea, 0xe7, 0x55, 0x91, 0x33, 0x93, 0x16, 0xf9, 0x2d, 0x02, 0x81, 0xcf,
	0xef, 0x2b, 0x35, 0xfc, 0x2a, 0xc1, 0xec, 0xa4, 0x09, 0x7e, 0x83, 0xe0, 0xce, 0x28, 0xc1, 0xf3,
	0x21, 0xe8, 0xc2, 0x52, 0x3b, 0x0c, 0x19, 0xa9, 0xa3, 0xb0, 0x36, 0x8e, 0xc4, 0x68, 0x39, 0xa5,
	0x18, 0x33, 0xc1, 0x57, 0x81, 0x34, 0xdc, 0xbe, 0xb2, 0x57, 0xfe, 0x09, 0x81, 0xb0, 0xaf, 0x57,
	0x9f, 0xee, 0xd8, 0x6e, 0x60, 0xbb, 0xad, 0xe8, 0xe8, 0x7f, 0x04, 0x10, 0x1e, 0x42, 0x83, 0xf7,
	0x99, 0xfb, 0x35, 0x3f, 0x7e, 0x2e, 0x86, 0x4f, 0x37, 0xe5, 0xf5, 0x10, 0xfb, 0x64, 0x50, 0x42,
	0x5a, 0xbe, 0x39, 0x7c, 0xe4, 0x5d, 0x83, 0xaf, 0xcf, 0xb3, 0x50, 0xdc, 0x22, 0x9e, 0xb5, 0x6d,
	0x7f, 0x71, 0x68, 0x5b, 0x76, 0xd0, 0x6f, 0x78, 0xac, 0x6b, 0x5b, 0xd4, 0x8b, 0x18, 0xec, 0xa6,
	0xa8, 0x79, 0xf0, 0x22, 0x35, 0x17, 0x0f, 0xc1, 0x74, 0x49, 0x47, 0xb0, 0xec, 0x1f, 0x76, 0x3a,
	0x4e, 0xdf, 0x48, 0x55, 0x36, 0x99, 0x66, 0x2d, 0x46, 0x10, 0x97, 0x0f, 0xec, 0x11, 0x2c, 0x37,
	0x99, 0xe7, 0xb1, 0x9e, 0x91, 0x7a, 0x98, 0x26, 0x84, 0x1c, 0x41, 0x5c, 0x9e, 0x93, 0x5f, 0x11,
	0x14, 0xaa, 0xd4, 0xa1, 0x2d, 0x12, 0xb0, 0x69, 0xf9, 0x7a, 0x30, 0x66, 0x54, 0x26, 0x23, 0x6b,
	0x64, 0x68, 0x7e, 0x46, 0x90, 0xd7, 0x7b, 0xa4, 0x73, 0x13, 0xb4, 0xfc, 0x82, 0x60, 0x41, 0x27,
	0x5d, 0xdb, 0x6d, 0xf9, 0x37, 0xa5, 0x35, 0x35, 0xe2, 0xb9, 0x37, 0x41, 0xcb, 0x3f, 0x59, 0x98,
	0x8d, 0x60, 0xdf, 0x87, 0xdc, 0xff, 0xfb, 0x9b, 0xe5, 0xe9, 0x17, 0xaf, 0x61, 0xd9, 0x69, 0xbf,
	0x86, 0xcd, 0x4c, 0xed, 0x35, 0x2c, 0xc5, 0xf2, 0xdc, 0xd4, 0x2c, 0x7f, 0x7b, 0x80, 0x20, 0x3f,
	0x74, 0x11, 0x17, 0x61, 0x65, 0x63, 0x5b, 0x56, 0x77, 0x8c, 0xbd, 0x67, 0x8d, 0x9a, 0xb1, 0x5f,
	0xd7, 0x1b, 0xb5, 0x0d, 0xf5, 0xb1, 0x5a, 0xab, 0x0a, 0x99, 0x91, 0xd8, 0x96, 0xac, 0x55, 0x0d,
	0x65, 0x57, 0xd3, 0x76, 0x9f, 0x08, 0x28, 0x2d, 0xa6, 0xef, 0x37, 0x1a, 0xdb, 0xcf, 0x84, 0x2c,
	0x5e, 0x85, 0xa5, 0x44, 0xac, 0x5a, 0xdb, 0xae, 0x6d, 0xca, 0x7b, 0xbb, 0x9a, 0x30, 0x83, 0x17,
	0xe1, 0x76, 0x22, 0x52, 0x93, 0xb5, 0xba, 0x90, 0xc3, 0x2b, 0x80, 0x13, 0x9b, 0xba, 0xfc, 0xb1,
	0x5a, 0xdf, 0xd4, 0x85, 0xd9, 0x91, 0x64, 0xfd, 0x89, 0xdc, 0x10, 0xe6, 0xf0, 0x1b, 0x70, 0x27,
	0xc9, 0x57, 0xaf, 0x3e, 0x35, 0x76, 0xd4, 0xfa, 0x9e, 0x5a, 0xdf, 0x14, 0x5e, 0x2b, 0xe6, 0xbe,
	0xfc, 0x4e, 0xcc, 0x28, 0xea, 0xf1, 0x73, 0x31, 0x73, 0x7c, 0x2a, 0xa2, 0x93, 0x53, 0x11, 0xfd,
	0x7d, 0x2a, 0xa2, 0xaf, 0xcf, 0xc4, 0xcc, 0xc9, 0x99, 0x98, 0xf9, 0xe3, 0x4c, 0xcc, 0x7c, 0xf2,
	0x4e, 0xa2, 0x3b, 0xa1, 0xbb, 0xeb, 0x0e, 0x69, 0xfa, 0x7c, 0x55, 0x39, 0x4a, 0x7c, 0x16, 0xf1,
	0x36, 0x35, 0xe7, 0xf8, 0x57, 0xca, 0x7b, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x05, 0x33, 0xc9,
	0x45, 0x35, 0x0d, 0x00, 0x00,
}

func (m *BaseClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Reward.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClaims(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BaseMultiClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseMultiClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseMultiClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reward) > 0 {
		for iNdEx := len(m.Reward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Reward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.RewardFactor.Size()
		i -= size
		if _, err := m.RewardFactor.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintClaims(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.CollateralType) > 0 {
		i -= len(m.CollateralType)
		copy(dAtA[i:], m.CollateralType)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.CollateralType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardIndexesProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardIndexesProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardIndexesProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardIndexes) > 0 {
		for iNdEx := len(m.RewardIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TypedRewardIndexes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypedRewardIndexes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedRewardIndexes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardIndexes) > 0 {
		for iNdEx := len(m.RewardIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CollateralType) > 0 {
		i -= len(m.CollateralType)
		copy(dAtA[i:], m.CollateralType)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.CollateralType)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClaimType != 0 {
		i = encodeVarintClaims(dAtA, i, uint64(m.ClaimType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiRewardIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiRewardIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiRewardIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardIndexes) > 0 {
		for iNdEx := len(m.RewardIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CollateralType) > 0 {
		i -= len(m.CollateralType)
		copy(dAtA[i:], m.CollateralType)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.CollateralType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiRewardIndexesProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiRewardIndexesProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiRewardIndexesProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MultiRewardIndexes) > 0 {
		for iNdEx := len(m.MultiRewardIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MultiRewardIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *USDXMintingClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *USDXMintingClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *USDXMintingClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardIndexes) > 0 {
		for iNdEx := len(m.RewardIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.BaseClaim.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClaims(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HardLiquidityProviderClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HardLiquidityProviderClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HardLiquidityProviderClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BorrowRewardIndexes) > 0 {
		for iNdEx := len(m.BorrowRewardIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BorrowRewardIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SupplyRewardIndexes) > 0 {
		for iNdEx := len(m.SupplyRewardIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SupplyRewardIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.BaseMultiClaim.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClaims(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DelegatorClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegatorClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegatorClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardIndexes) > 0 {
		for iNdEx := len(m.RewardIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.BaseMultiClaim.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClaims(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SwapClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardIndexes) > 0 {
		for iNdEx := len(m.RewardIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.BaseMultiClaim.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClaims(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SavingsClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavingsClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavingsClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardIndexes) > 0 {
		for iNdEx := len(m.RewardIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.BaseMultiClaim.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClaims(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EarnClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EarnClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EarnClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardIndexes) > 0 {
		for iNdEx := len(m.RewardIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.BaseMultiClaim.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClaims(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Claim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Claim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Claim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardIndexes) > 0 {
		for iNdEx := len(m.RewardIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Reward) > 0 {
		for iNdEx := len(m.Reward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Reward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClaims(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintClaims(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintClaims(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintClaims(dAtA []byte, offset int, v uint64) int {
	offset -= sovClaims(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BaseClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	l = m.Reward.Size()
	n += 1 + l + sovClaims(uint64(l))
	return n
}

func (m *BaseMultiClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	if len(m.Reward) > 0 {
		for _, e := range m.Reward {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	return n
}

func (m *RewardIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollateralType)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	l = m.RewardFactor.Size()
	n += 1 + l + sovClaims(uint64(l))
	return n
}

func (m *RewardIndexesProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RewardIndexes) > 0 {
		for _, e := range m.RewardIndexes {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	return n
}

func (m *TypedRewardIndexes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClaimType != 0 {
		n += 1 + sovClaims(uint64(m.ClaimType))
	}
	l = len(m.CollateralType)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	if len(m.RewardIndexes) > 0 {
		for _, e := range m.RewardIndexes {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	return n
}

func (m *MultiRewardIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollateralType)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	if len(m.RewardIndexes) > 0 {
		for _, e := range m.RewardIndexes {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	return n
}

func (m *MultiRewardIndexesProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MultiRewardIndexes) > 0 {
		for _, e := range m.MultiRewardIndexes {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	return n
}

func (m *USDXMintingClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BaseClaim.Size()
	n += 1 + l + sovClaims(uint64(l))
	if len(m.RewardIndexes) > 0 {
		for _, e := range m.RewardIndexes {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	return n
}

func (m *HardLiquidityProviderClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BaseMultiClaim.Size()
	n += 1 + l + sovClaims(uint64(l))
	if len(m.SupplyRewardIndexes) > 0 {
		for _, e := range m.SupplyRewardIndexes {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	if len(m.BorrowRewardIndexes) > 0 {
		for _, e := range m.BorrowRewardIndexes {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	return n
}

func (m *DelegatorClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BaseMultiClaim.Size()
	n += 1 + l + sovClaims(uint64(l))
	if len(m.RewardIndexes) > 0 {
		for _, e := range m.RewardIndexes {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	return n
}

func (m *SwapClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BaseMultiClaim.Size()
	n += 1 + l + sovClaims(uint64(l))
	if len(m.RewardIndexes) > 0 {
		for _, e := range m.RewardIndexes {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	return n
}

func (m *SavingsClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BaseMultiClaim.Size()
	n += 1 + l + sovClaims(uint64(l))
	if len(m.RewardIndexes) > 0 {
		for _, e := range m.RewardIndexes {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	return n
}

func (m *EarnClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BaseMultiClaim.Size()
	n += 1 + l + sovClaims(uint64(l))
	if len(m.RewardIndexes) > 0 {
		for _, e := range m.RewardIndexes {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	return n
}

func (m *Claim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovClaims(uint64(m.Type))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovClaims(uint64(l))
	}
	if len(m.Reward) > 0 {
		for _, e := range m.Reward {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	if len(m.RewardIndexes) > 0 {
		for _, e := range m.RewardIndexes {
			l = e.Size()
			n += 1 + l + sovClaims(uint64(l))
		}
	}
	return n
}

func sovClaims(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozClaims(x uint64) (n int) {
	return sovClaims(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BaseClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Reward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseMultiClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseMultiClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseMultiClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reward = append(m.Reward, types.Coin{})
			if err := m.Reward[len(m.Reward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardFactor", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewardFactor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardIndexesProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardIndexesProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardIndexesProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardIndexes = append(m.RewardIndexes, RewardIndex{})
			if err := m.RewardIndexes[len(m.RewardIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypedRewardIndexes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypedRewardIndexes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypedRewardIndexes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimType", wireType)
			}
			m.ClaimType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimType |= ClaimType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardIndexes = append(m.RewardIndexes, RewardIndex{})
			if err := m.RewardIndexes[len(m.RewardIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiRewardIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiRewardIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiRewardIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardIndexes = append(m.RewardIndexes, RewardIndex{})
			if err := m.RewardIndexes[len(m.RewardIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiRewardIndexesProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiRewardIndexesProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiRewardIndexesProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiRewardIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiRewardIndexes = append(m.MultiRewardIndexes, MultiRewardIndex{})
			if err := m.MultiRewardIndexes[len(m.MultiRewardIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *USDXMintingClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: USDXMintingClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: USDXMintingClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseClaim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardIndexes = append(m.RewardIndexes, RewardIndex{})
			if err := m.RewardIndexes[len(m.RewardIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HardLiquidityProviderClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HardLiquidityProviderClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HardLiquidityProviderClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseMultiClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseMultiClaim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyRewardIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplyRewardIndexes = append(m.SupplyRewardIndexes, MultiRewardIndex{})
			if err := m.SupplyRewardIndexes[len(m.SupplyRewardIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowRewardIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BorrowRewardIndexes = append(m.BorrowRewardIndexes, MultiRewardIndex{})
			if err := m.BorrowRewardIndexes[len(m.BorrowRewardIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegatorClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegatorClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegatorClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseMultiClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseMultiClaim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardIndexes = append(m.RewardIndexes, MultiRewardIndex{})
			if err := m.RewardIndexes[len(m.RewardIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseMultiClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseMultiClaim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardIndexes = append(m.RewardIndexes, MultiRewardIndex{})
			if err := m.RewardIndexes[len(m.RewardIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavingsClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavingsClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavingsClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseMultiClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseMultiClaim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardIndexes = append(m.RewardIndexes, MultiRewardIndex{})
			if err := m.RewardIndexes[len(m.RewardIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EarnClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EarnClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EarnClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseMultiClaim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseMultiClaim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardIndexes = append(m.RewardIndexes, MultiRewardIndex{})
			if err := m.RewardIndexes[len(m.RewardIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Claim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Claim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Claim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ClaimType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reward = append(m.Reward, types.Coin{})
			if err := m.Reward[len(m.Reward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClaims
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClaims
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardIndexes = append(m.RewardIndexes, MultiRewardIndex{})
			if err := m.RewardIndexes[len(m.RewardIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClaims(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClaims
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClaims(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClaims
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClaims
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthClaims
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupClaims
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthClaims
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthClaims        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClaims          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupClaims = fmt.Errorf("proto: unexpected end of group")
)
